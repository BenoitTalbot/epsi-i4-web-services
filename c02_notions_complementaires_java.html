<!doctype html>
<html lang="fr">

	<head>
		<meta charset="utf-8">
		<title>I4 Web Services</title>
		<meta name="author" content="David Gayerie">

		<link rel="stylesheet" href="assets/cours.css">
		<link rel="stylesheet" href="assets/cours-paper.css" media="print">

		<!--[if lt IE 9]>
		<script src="assets/reveal.js-2.5.0/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<nav>
				<script>
					if(/^https?:/.test(window.location)) {
						document.write('<a href="https://github.com/spoonless/epsi-i4-web-services/archive/gh-pages.zip" class="download">Télécharger</a>');
						document.write('<a href="' + window.location.toString().replace(".html", ".pdf") + '" class="pdf">PDF</a>');
					}
				</script>
			</nav>

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section class="title">
					<img alt="Java logo" src="assets/images/java-logo.png">
					<h1 class="small">Notions complémentaires en Java</h1>
					<p class="copyright">EPSI I4 Web Services / <a class="explicit" href="mailto:david.gayerie.epsi@mailoo.org">David Gayerie</a> - 2013-2014</p>
				</section>
				<section>
					<section>
						<article>
							<header>Compilation</header>
							<p>La compilation du code source ne produit pas un binaire mais du <em>bytecode</em></p>
							<figure>
								<figcaption>Le fichier source Hello.java</figcaption>
								<pre><code class="java" data-trim>
public class Hello {
  public static void main(String[] args) {
    System.out.println("hello the world!");
  }
}
								</code></pre>
							</figure>
							<figure>
								<figcaption>Le fichier Hello.class désassemblé avec <em>javap</em></figcaption>
								<pre><code class="java" data-trim>
public class Hello {
  public static void main(java.lang.String[]);
    Signature: ([Ljava/lang/String;)V
    Code:
       0: getstatic     #16
       3: ldc           #22
       5: invokevirtual #24
       8: return        
}
								</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Le bytecode est exécutable dans une machine virtuelle Java (JVM)</p>
							<figure>
								<figcaption>Le fichier source Hello.java</figcaption>
								<pre><code class="java" data-trim>
public class Hello {
  public static void main(String[] args) {
    System.out.println("hello the world!");
  }
}
								</code></pre>
							</figure>
							<figure>
								<figcaption>Compilation du fichier Hello.java</figcaption>
								<pre><code class="bash">$ javac Hello.java</code></pre>
							</figure>
							<figure>
								<figcaption>Exécution de la classe Hello</figcaption>
								<pre><code class="bash" data-trim>
$ java Hello
hello the world!
								</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<p>Conséquence : Un programme est portable sur un système disposant d'une machine virtuelle Java.</p>
						<blockquote>Compile once, run anywhere</blockquote>
					</section>
				</section>

				<section>
					<section>
						<article>
							<header>Édition de lien</header>
							<p>Java utilise un système de <strong>lien dynamique à l'exécution</strong> (dynamic link).</p>
							<p>Un programme Java est une collection de fichiers .class parfois rassemblés dans une archive (i.e. fichier .jar).</p>
							<p>L'édition de lien se fait au chargement d'un fichier .class dans la JVM. 
							Le <em><strong>ClassLoader</strong></em> a la responsabilité de charger les classes manquantes.</p>
							<p>Le <em>ClassLoader</em> est accessible programmatiquement.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Étant donné deux classes <code>Spaceship</code> et <code>Engine</code></p>
							<figure>
								<figcaption>Spaceship.java</figcaption>
								<pre><code class="java" data-trim>
public class Spaceship {
  private Engine engine = new Engine();

  public void takeoff() {
    engine.startup();
  }
}
								</code></pre>
								<figcaption>Engine.java</figcaption>
								<pre><code class="java" data-trim>
public class Engine {
  public void startup() {
    // ...
  }
}
								</code></pre>
							</figure>
							<p>Une référence à la classe <code>Spaceship</code> dans un programme entraînera 
							son chargement par le <em>ClassLoader</em>. La classe <code>Engine</code> 
							sera également chargée car elle est nécessaire au fonctionnement de <code>Spaceship</code>.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Si une classe ne peut pas être trouvée, on obtient l'erreur <code>NoClassDefFoundError</code> <strong>à l'exécution</strong>.</p>
							<figure>
								<figcaption>Erreur à l'exécution lorsque la classe <code>Engine</code> n'est pas trouvable</figcaption>
								<pre><code class="java" data-trim>
Exception in thread "main" java.lang.NoClassDefFoundError: Engine
        at Spaceship.&lt;init&gt;(Spaceship.java:2)
Caused by: java.lang.ClassNotFoundException: Engine
        at java.net.URLClassLoader$1.run(URLClassLoader.java:202)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
        ... 2 more
								</code></pre>
							</figure>
						</article>
        			</section>
        			<section>
        				<article>
        					<p>Le <em>ClassLoader</em> par défaut de la JVM charge les classes à partir des fichiers .class.</p>
        					<p>L'ensemble des répertoires et des archives contenant les <em>packages</em> et les fichiers .class est appelé le <strong>classpath</strong>.</p>
							<figure>
								<figcaption>Lancement d'un programme sous *NIX en spécifiant le classpath</figcaption>
								<pre><code class="bash" data-trim>java -classpath .:spaceship/bin:lib/galaxy.jar SpaceBattle</code></pre>
							</figure>
							<figure>
								<figcaption>Lancement d'un programme sous Windows en spécifiant le classpath</figcaption>
								<pre><code class="dos" data-trim>java -classpath .;spaceship/bin;lib/galaxy.jar SpaceBattle</code></pre>
							</figure>
							<p>A noter : le séparateur pour le paramètre classpath est différent selon les OS ':' sous *NIX et ';' sous Windows.</p>
        				</article>
        			</section>
        		</section>


        		<section>
        			<section>
        				<article>
        					<header>Les paquets (packages)</header>
        					<p>Afin d'éviter la collision de nom (des classes, interfaces, énumérations ou annotations portant le même nom),
        					Java supporte la notion de paquets (packages).</p>
        					<p>Un package est simplement un répertoire dans lequel sont placés les fichiers Java.</p>
        					<p>Un package définit un espace de nom commun à l'ensemble des éléments de ce package.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Le package d'un fichier source doit être la première instruction du fichier. 
        					Il est spécifié avec le mot-clé <strong>package</strong>.<p>
        					<pre><code class="java" data-trim>
package com.battleship;

public class Spaceship {

  // ...

}
        					</code></pre>
        					<p>Le fichier source doit se trouver dans le répertoire </p>
        					<pre><code class="dos" data-trim>com/battleship</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Pour référencer la classe <code>Spaceship</code> dans un autre fichier source, on peut :</p>
        					<ul>
        						<li>Soit utiliser son nom complet (c'est-à-dire en incluant le package) :
        							<pre><code class="java" data-trim>com.battleship.Spaceship spaceship = new com.battleship.Spaceship();</code></pre>
        						</li>
        						<li>Soit inclure la classe dans l'espace de noms courant avec l'instruction <strong>import</strong> en début de fichier :
        							<pre><code class="java" data-trim>import com.battleship.Spaceship;</code></pre>
        							On peut alors écrire
        							<pre><code class="java" data-trim>Spaceship spaceship = new Spaceship();</code></pre>
        						</li>
        					</ul> 
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>La mot-clé <strong>import</strong> permet aussi d'inclure la totalité des éléments
        					d'un package en utilisant * :</p>
        					<pre><code class="java" data-trim>import com.battleship.*;</code></pre>
        					<p>Il n'est pas nécessaire d'importer un élément qui se trouve dans le même package.</p>
        					<p>Les éléments appartenant au package <strong>java.lang</strong> (comme la classe <code>String</code> par exemple)
        					sont implicitement importés.</p>
        					<p>Par convention, le nom des packages s'écrit en minuscules.</p>
        					<p>Les packages commençant par <strong>java</strong> ou <strong>javax</strong> sont réservés.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Il est également possible d'importer les éléments <strong>static</strong> d'une classe.<p>
        					<p>Cela permet d'invoquer des méthodes ou de référencer les attributs sans avoir à les préfixer par le nom de la classe.</p>
							<figure>
								<pre><code class="java" data-trim>
class Angle {
  private double radianAngle;

  public Angle(double radianAngle) {
    this.radianAngle = Math.max(0d, radianAngle);
    this.radianAngle = Math.min(2 * Math.PI, this.radianAngle);
  }
}
								</code></pre>
								<pre><code class="java" data-trim>
import static java.lang.Math.*;

class Angle {
  private double radianAngle;

  public Angle(double radianAngle) {
    this.radianAngle = max(0d, radianAngle);
    this.radianAngle = min(2 * PI, this.radianAngle);
  }
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Un package peut contenir un fichier spécial : <strong>package-info.java</strong></p>
        					<p>Ce fichier contient obligatoirement l'instruction <strong>package</strong> comme pour un fichier normal.</p>
        					<p>De plus, il peut contenir la documentation du package mais également des annotations de niveau package.</p>
							<figure>
								<figcaption>Exemple d'un fichier package-info.java</figcaption>
									<pre><code class="java" data-trim>
/**
 * La javadoc du package vient ici...
 */
@javax.xml.bind.annotation.XmlSchema
(namespace = "http://www.epsi.fr/i4-web-services/myfirstwebservice")
package fr.epsi.i4_web_services.myfirstwebservice;
								</code></pre>
							</figure>
        				</article>
        			</section>
				</section>

        		<section>
        			<section>
        				<article>
        					<header>Les exceptions</header>
        					<p>Une exception permet d'interrompre un traitement lorsqu'une situation exceptionnelle se produit.</p>
        					<p>Une exception est propagée dans la pile des appels de méthodes. 
        					Elle peut être interceptée progammatiquement.</p>
        					<p>Si elle n'est interceptée par aucune méthode, elle remonte la pile d'appel et interrompt le thread d'exécution.</p>
        					<p>S'il s'agit du thread principal, le programme s'interrompt en erreur.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Les exceptions sont représentées par des classes qui ont comme ancêtre <strong>java.lang.Throwable</strong></p>
							<figure>
								<figcaption>La hiérarchie de base des exceptions</figcaption>
								<img src="assets/images/exception_inheritance.png"/>
							</figure>
        					<p>Les classes héritant de <strong>java.lang.Error</strong> sont réservées pour la JVM afin de signaler des erreurs systèmes :</p>
        					<ul>
        						<li>NoClassDefFoundError</li>
        						<li>OutOfMemoryError</li>
        						<li>StackOverflowError</li>
        						<li>...</li>
        					</ul>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Pour lancer une exception on utilise le mot-clé <strong>throw</strong>.</p>
							<pre><code class="java" data-trim>
// La classe hérite de exception qui hérite elle-même de throwable.
// Par convention le nom de la classe se termine par Exception.
public class EndOfTheWorldException extends Exception {
}
							</code></pre>
							<p>On peut maintenant signaler l'événement exceptionnel de la fin du monde en lançant l'exception :</p>
							<pre><code class="java" data-trim>
throw new EndOfTheWorldException();
							</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>On distingue deux catégories d'exception :</p>
        					<ul>
        						<li>Les <em>checked exceptions</em> apparaissent dans la signature des méthodes qui peuvent
        						les lancer ou les propager lors d'un appel grâce au mot-clé <strong>throws</strong>.
									<pre><code class="java" data-trim>
public void pressTheRedButton() throws EndOfTheWorldException {
  if(this.isTheEndOfTheWorld()) {
    throw new EndOfTheWorldException();
  }
  // ...
}

public void doSomethingSilly() throws EndOfTheWorldException {
  pressTheRedButton();
}
									</code></pre>
									<p>Plusieurs <em>checked exceptions</em> peuvent être spécifiées en les séparant par une virgule :</p>
									<pre><code class="java" data-trim>
public Stuff buy(long amount, Currency currency) 
  throws NotEnoughMoneyException, NotAcceptedCurrencyException, 
         StuffUnavailableException {
  // ...
}
									</code></pre>
								</li>
							</ul>
        				</article>
        			</section>
        			<section>
        				<article>
        					<ul>
        						<li>Les <em>unchecked exceptions</em> héritent directement ou indirectement 
        						de <strong>RuntimeException</strong> ou de <strong>Error</strong>.
        						<p>La déclaration de ces exceptions est <strong>optionnelle</strong> 
        						dans la signature des méthodes pouvant les lancer ou les propager.</p>
									<pre><code class="java" data-trim>
public class EntityNotFoundException extends RuntimeException {
  public EntityNotFoundException(String message) {
    super(message);
  } 
}
									</code></pre>
									<pre><code class="java" data-trim>
// Il n'est pas nécessaire d'ajouter :
//       throws EntityNotFoundException
// car EntityNotFoundException hérite de RuntimeException.
public Entity get(String id) {
  Entity entity = database.load(id);
  if (entity == null) {
    throw new EntityNotFoundException("Cannot find entity " + id);
  }
  return entity;
}
									</code></pre>
								</li>
							</ul>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Une exception peut être interceptée par une méthode dans la pile d'appel :</p>
							<pre><code class="java" data-trim>
try {
  evilMind.pressTheRedButton();
}
catch (EndOfTheWorldException ex) {
  hero.saveTheWorld();
}
							</code></pre>
        					<p>Le block défini par le mot-clé <strong>catch</strong> est exécuté <strong>uniquement</strong>
        					si une exception de type <strong>EndOfTheWorldException</strong> est lancée lors de l'exécution
        					du block défini par le mot-clé <strong>try</strong>.
        					</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Un block défini par le mot-clé <strong>finally</strong> est exécuté systématiquement après un block
        					<strong>try</strong> et un block <strong>catch</strong> (si une exception a été attrapée).</p>
							<pre><code class="java" data-trim>
try {
  evilMind.pressTheRedButton();
}
catch (EndOfTheWorldException ex) {
  hero.saveTheWorld();
}
finally {
  // Finalement, le héros arrête l'esprit du mal qu'il ait eu
  // ou non à sauver le monde.
  hero.arrest(evilMind);
}
							</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Un block <strong>finally</strong> est souvent utilisé en Java pour libérer 
        					des ressources système à la fin d'un traitement.</p>
							<pre><code class="java" data-trim>
public String getFileContent(String filename) throws java.io.IOException {
  java.io.FileReader reader = new java.io.FileReader(filename);
  try {
    int nbCharRead = 0;
    char[] buffer = new char[1024];
    StringBuilder builder = new StringBuilder();
    // L'appel à reader.read peut lancer une java.io.IOException
    while ((nbCharRead = reader.read(buffer)) &gt;= 0) {
      builder.append(buffer, 0, nbCharRead);
    }
    // le retour explicite n'empêche pas l'exécution du block finally.
    return builder.toString();
  }
  // Ce block est obligatoirement exécuté après le block try.
  // Ainsi le flux de lecture sur le fichier est fermé 
  // avant le retour de la méthode. 
  finally {
    reader.close();
  }
}
							</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Depuis Java 7, on peut utiliser une expression 
        					<em><a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="javadoc">try-with-resources</a></em>. 
        					Pour gérer le cas particulier des resources que l'on souhaite fermer automatiquement.</p>
							<pre><code class="java" data-trim>
public String getFileContent(String filename) throws java.io.IOException {
  // La resource que l'on souhaite fermer automatiquement et
  // déclarer après le mot-clé try entre parenthèses.  
  try (java.io.FileReader reader = new java.io.FileReader(filename)) {
    int nbCharRead = 0;
    char[] buffer = new char[1024];
    StringBuilder builder = new StringBuilder();
    while ((nbCharRead = reader.read(buffer)) &gt;= 0) {
      builder.append(buffer, 0, nbCharRead);
    }
    return builder.toString();
  }
  // On évite l'utilisation du bloc finally de l'exemple
  // précédent. Le try-with-resource garantit que reader.close()
  // est appelé.
}
							</code></pre>
        					<p>Seules les classes implémentant l'interface 
        					<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html" target="javadoc">java.lang.AutoCloseable</a> 
        					ou <a href="http://docs.oracle.com/javase/7/docs/api/java/io/Closeable.html" target="javadoc">java.io.Closeable</a> 
        					peuvent être utilisées dans une expression <em>try-with-resources</em>.</p>
        				</article>
        			</section>
				</section>

        		<section>
        			<section>
        				<article>
        					<header>Les interfaces</header>
        					<p>Une interface permet d'établir un contrat implémenté par des classes. 
        					L'interface ne fournit pas d'implémentation mais uniquement la signature des méthodes à implémenter.</p>
        					<p>Une interface peut déclarer des constantes souvent utilisées comme valeurs remarquables de retour
        					ou de paramètres.</p>
							<figure>
								<figcaption>Un exemple d'interface</figcaption>
								<pre><code class="java" data-trim>
public interface Playable {
  int FIRST_STREAM = 0;
  int LAST_STREAM = Integer.MAX_VALUE;

  void play() throws PlayerNotReadyException, StreamInterruptedException;
  void stop();
  // on peut passer le numéro du flux à jouer 
  // ou FIRST_STREAM ou LAST_STREAM
  boolean selectStream(int streamNum);
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Les attributs déclarés dans une interface sont implicitement <strong>public static final</strong>.
        					Ce sont donc bien des constantes.</p> 
        					<p>Les méthodes déclarées dans une interface sont implicitement <strong>public abstract</strong>.</p> 
							<figure>
								<figcaption>Une interface explicitant tous les mots-clés</figcaption>
								<pre><code class="java" data-trim>
public interface Playable {

  // les mots-clés public static final peuvent être explicités.
  public static final int FIRST_STREAM = 0;
  public static final int LAST_STREAM = Integer.MAX_VALUE;

  // les mots-clés public abstract peuvent être explicités.
  public abstract void play() 
             throws PlayerNotReadyException, StreamInterruptedException;
  public abstract void stop();
  public abstract boolean selectStream(int streamNum);
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Une classe <strong>concrète</strong> héritant d'une interface doit fournir
        					une implémentation de toutes les méthodes de l'interface.</p> 
							<figure>
								<figcaption>Une classe implémentant l'interface Playable</figcaption>
								<pre><code class="java" data-trim>
public class VideoPlayer implements Playable {

  public void play() {
    // implementation here
  }
  
  public void stop() {
    // implementation here
  }
  
  public boolean selectStream(int streamNum) {
    // implementation here
  }
}
								</code></pre>
							</figure>
	        				<p>Les règles à respecter dans la signature des méthodes de la classe sont les mêmes que pour
	        				la redéfinition de méthode (overriding).</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Une interface permet d'introduire un <em>couplage faible</em> entre les éléments d'un système.</p>
							<figure>
								<figcaption>Un exemple de l'utilisation de l'interface Playable</figcaption>
								<img src="assets/images/playable_inheritance.png"/>
							</figure>
	        				<p>Si la classe <code>ButtonBar</code> permet d'afficher graphiquement des boutons "play" et "stop", 
	        				elle permet à l'utilisateur de contrôler n'importe quelle classe implémentant <code>Playable</code>.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Une interface peut hériter <strong>d'une ou de plusieurs</strong> autres interfaces.</p> 
							<figure>
								<figcaption>L'héritage d'interface</figcaption>
								<pre><code class="java" data-trim>
public interface Navigable {
  void next();
  void previous();
}
								</code></pre>
								<pre><code class="java" data-trim>
public interface Playable {
  void play() throws PlayerNotReadyException, StreamInterruptedException;
  void stop();
}
								</code></pre>
								<pre><code class="java" data-trim>
// Une classe implémentant l'interface Player doit
// fournir une implémentation des méthodes déclarées
// par Player, Navigable et Playable.
public interface Player extends Navigable, Playable {
  int getSelectedStream();
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Certaines interfaces ne définissent aucune méthode. On parle alors d'<strong>interfaces marqueur</strong>.
        					Elles indiquent que les classes qui les implémentent ont <em>certaines propriétés</em>.</p>
        					<p>L'API Java standard propose des interfaces marqueurs :</p>
        					<ul>
        						<li><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Cloneable.html" target="javadoc">java.lang.Cloneable</a></li>
        						<li><a href="http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html" target="javadoc">java.io.Serializable</a> (nous y reviendrons)</li>
        						<li>...</li>
        					</ul>
        				</article>
        			</section>
        			<section>
        				<article>
							<figure>
								<figcaption>Les interfaces implémentées par la classe java.util.ArrayList</figcaption>
								<img src="assets/images/arraylist_interfaces.png"/>
							</figure>
        				</article>
        			</section>
				</section>
        		<section>
					<section>
        				<article>
        					<header>La sérialisation</header>
        					<p>La sérialisation est un mécanisme permettant d'écrire ou de lire dans un flux les données 
        					binaires d'un objet ou d'une hiérarchie d'objets.</p>
        					<p>La sérialisation permet, par exemple, de sauvegarder dans un fichier ou de transmettre 
        					à travers un réseau, la représentation d'un objet.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Une classe est sérialisable si elle-même ou une classe parente implémente l'interface marqueur 
        					<a href="http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html" target="javadoc">java.io.Serializable</a>.</p>
							<figure>
								<figcaption>Une classe sérialisable</figcaption>
								<pre><code class="java" data-trim>
package epsi;

import java.io.Serializable;

public class Student implements Serializable {

  private static final long serialVersionUID = 1L;

  private final String name;
  private final int age;

  public Student(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public String toString() {
    return "Hello, my name is " + name +
           " and I am " + age + " years old.";
  }
}
								</code></pre>
							</figure>
        				</article>
        			</section>
					<section>
        				<article>
        					<p>Si un objet contient un attribut non nul pointant sur un objet non sérialisable, 
        					la sérialisation échoue avec l'exception <em>java.io.NotSerializableException</em>.</p>
        					<p>Cependant, la serialisation ignore :</p>
        					<ul>
        						<li>Les attributs de classe (<strong>static</strong>)</li>
        						<li>Les attributs déclarés avec le mot-clé <strong>transient</strong></li>
        						<li>Les attributs des classes parentes n'implémentant pas java.io.Serializable</li>
        					</ul>
        				</article>
				</section>
        		<section>
        				<article>
        					<p>Il existe un attribut jouant un rôle spécial :<br><strong>serialVersionUID</strong>.</p>
							<pre><code class="java" data-trim>
private static final long serialVersionUID = -2939239776154334018L;
							</code></pre>
							<p>Cet attribut permet de versionner la définition d'une classe lors de la sérialisation.
							Pendant la désérialisation, la version des données sérialisées est comparée à la version
							de la classe Java chargée par la JVM. Si les version diffèrent, la désérialisation se
							termine avec l'exception<br>
							<a href="http://docs.oracle.com/javase/7/docs/api/java/io/InvalidClassException.html" target="javadoc">java.io.InvalidClassException</a>.</p> 
        				</article>
        			</section>
	        		<section>
        				<article>
        					<p>Pour sérialiser un objet, on utilise la classe 
        					<a href="http://docs.oracle.com/javase/7/docs/api/java/io/ObjectOutputStream.html" target="javadoc">java.io.ObjectOutputStream</a> 
        					qui propose la méthode writeObject(Object).</p>
								<pre><code class="java" data-trim>
Student student = new Student("John Doe", 24);
try (ObjectOutputStream oos = new ObjectOutputStream(outputStream)) {
  oos.writeObject(student);
}
								</code></pre>
        					<p>Pour désérialiser un objet, on utilise la classe 
        					<a href="http://docs.oracle.com/javase/7/docs/api/java/io/ObjectInputStream.html" target="javadoc">java.io.ObjectInputStream</a> 
        					qui propose la méthode readObject().</p>
								<pre><code class="java" data-trim>
Student student = null;
try (ObjectInputStream ois = new ObjectInputStream(inputStream)) {
  student = Student.class.cast(ois.readObject());
}
								</code></pre>
        				</article>
        			</section>
				</section>
        		<section>
        			<section>
        				<article>
        					<header>La synchronisation</header>
        					<p>Lorsqu'un programme s'exécute dans un environnement multi-thread, l'accès à des ressources partagées 
        					(mémoire, fichier, ...) devient problématique.</p>
        					<p>Comment garantir que les ressources demeurent cohérentes si plusieurs threads y accèdent en lecture
        					et en écriture ?</p>
        				</article>
        			</section>
        			<section>
        				<article>
							<figure>
								<figcaption>Une classe "sensible" dans un environnement multi-thread</figcaption>
								<pre><code class="java" data-trim>
/**
 * Un modèle de parking de voitures.
 */
public class CarPark {
	
  /**
   * @Return un ticket de parking pour chaque véhicule entrant
   */
  public Ticket park() throws NoPlaceAvailableException {
    // ...
  }

  /**
   * Enregistre la sortie de parking d'un véhicule selon son ticket
   */
  public void unpark(Ticket ticket) {
    // ...
  }
	
  /**
   * @Return le nombre de places disponibles 
   */
  public int getAvailablePlaces() {
    // ...
  }
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Dans un environnement serveur, l'accès à des ressources partagées est une problématique permanente 
        					car un serveur "évolué" s'exécute toujours dans un environnement multi-thread.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Il est possible en Java de synchroniser l'exécution des méthodes, c'est-à-dire de garantir qu'un seul thread 
        					à la fois peut exécuter du code synchronisé. On utilise pour cela le mot-clé <strong>synchronized</strong>.</p>
							<figure>
								<figcaption>Un exemple de méthodes synchronisées</figcaption>
								<pre><code class="java" data-trim>
public class CarPark {
	
  public synchronized Ticket park() throws NoPlaceAvailableException {
    // ...
  }

  public synchronized void unpark(Ticket ticket) {
    // ...
  }
	
  public synchronized int getAvailablePlaces() {
    // ...
  }
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Il est également possible de ne synchroniser qu'une portion de code. 
        					On fournit alors une instance d'objet non nulle qui sert de verrou.</p>
							<figure>
								<figcaption>Un exemple de bloc de code synchronisé avec un verrou</figcaption>
								<pre><code class="java">
  public void doSomethingInConcurrency(Resource sharedResource)
    synchronized(sharedResource) {
      sharedResource.setModificationDate(Calendar.getInstance());
      // ...
    }
  }
								</code></pre>
							</figure>
        					<p>A l'entrée du block synchronisé, un thread acquière le verrou (dans l'exemple&nbsp;: <em>sharedResource</em>). 
        					Tout autre thread voulant acquérir le verrou est bloqué jusqu'à ce 
        					que le verrou soit relâché automatiquement par la sortie du bloc d'exécution synchronisé.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Ainsi une méthode synchronisée est implicitement un bloc synchronisé sur l'instance de la classe (this).</p>
							<figure>
								<pre><code class="java" data-trim>
public class CarPark {
	
  public Ticket park() throws NoPlaceAvailableException {
    synchronized(this) {
      // ...
    }
  }

  public void unpark(Ticket ticket) {
    synchronized(this) {
      // ...
    }
  }
	
  public int getAvailablePlaces() {
    synchronized(this) {
      // ...
    }
  }
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>La synchronisation est une des solutions proposées par Java 
        					pour le partage de ressources dans la programmation concurrente.</p>
        					<p>Cette solution a plusieurs défauts majeurs&nbsp;: création de goulets d'étranglement, surcoût de cycle CPU, mauvaise scalabilité...</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>La gestion de ressources partagées dans un environnement concurrent est <strong>extrêmement</strong> délicate !</p>
        					<p>La meilleure solution consiste à <strong>limiter</strong> les ressources partagées entre threads et à en laisser la responsabilité à des
        					composants logiciel fiables (comme les gestionnaires de transaction, les conteneurs Java EE,...).
        				</article>
        			</section>
				</section>
        		<section>
        			<section>
        				<article>
        					<header>Les annotations</header>
        					<p>Les annotations en Java sont des marqueurs qui permettent d'ajouter des méta-données aux classes, 
        					aux méthodes, aux attributs, aux paramètres, aux variables, aux paquets ou aux annotations elles-mêmes.</p>
        					<p>Les annotations sont utilisées dans des domaines divers. Leur intérêt principal est de fournir une
        					<em>méta-information</em> qui pourra être exploitée par un programme.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Une annotation est un type (comme une classe ou une interface) du langage Java : 
        					elle peut être référencée par son nom complet ou importée depuis un autre paquet grâce au mot-clé 
        					<strong>import</strong>.</p>
        					<p>Une annotation n'est pas instanciée, elle est simplement accolée à l'élément qu'elle vient enrichir :</p>
								<pre><code class="java" data-trim>
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlElement;

// Une annotation de classe
public @XmlRootElement class Spaceship {

  // Plusieurs annotations sur un attribut
  private @XmlAttribute @XmlID String id;

  // Une autre annotation sur un attribut
  private @XmlElement Engine engine;
  
  // ...
}
								</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Certaines annotations déclarent des attributs
        					 (par exemple l'annotation <a target="javadoc" href="http://docs.oracle.com/javaee/7/api/javax/xml/bind/annotation/XmlElement.html">javax.xml.bind.annotation.XmlElement</a>)</p>
							<pre><code class="java">
  @XmlElement(name="moteur", required=true) 
  private Engine engine;
							</code></pre>
        					<p>Par convention, si un attribut de l'annotation s'appelle <strong>value</strong>
        					et qu'il est le seul paramètre spécifié, alors son nom peut être omis pour plus de lisibilité.</p> 
							<pre><code class="java">
  @SuppressWarnings("deprecation") 
  public void myMethod() {
    //...
  }

  @SuppressWarnings(value="deprecation") 
  public void myOtherMethod() {
    //...
  }
							</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Un nombre très limité d'annotations sont exploitées directement par le compilateur.</p>
        					<p>On trouve les annotations déclarées dans le paquet <strong>java.lang</strong>&nbsp;: </p>
        					<ul>
        						<li><a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/Deprecated.html">Deprecated</a></li>
        						<li><a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/Override.html">Override</a></li>
        						<li><a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/SuppressWarnings.html">SuppressWarnings</a></li>
        						<li><a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/SafeVarargs.html">SafeVarargs</a> (introduite en Java 7)</li>
        					</ul>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Une annotation est définie par sa <a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Retention.html">rétention</a>, 
        					c'est-à-dire la façon dont une annotation sera conservée. Les différentes rétentions d'annotation sont :</p>
        					<ul>
        						<li><strong>source</strong> : l'annotation est accessible durant la compilation mais n'est pas intégrée dans le fichier class généré.</li>
        						<li><strong>class</strong> : l'annotation est accessible durant la compilation, elle est intégrée dans le fichier class généré mais elle n'est pas chargée dans la JVM à l'exécution.</li>
        						<li><strong>runtime</strong> : l'annotation est accessible durant la compilation, elle est intégrée dans le fichier class généré et elle est chargée dans la JVM à l'exécution. Elle est accessible par introspection.</li>
        					</ul>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Pour les annotations de rétention <strong>source</strong>, la JVM prévoit un mécanisme pour inclure lors de la compilation 
        					des <a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html">processeurs d'annotations</a>. 
        					Par exemple, ces processeurs peuvent servir à vérifier le code ou générer du code supplémentaire.</p>
        					<p><a target="lombok" href="http://projectlombok.org/">Lombok</a> est un exemple de projet open-source fournissant des annotations permettant de générer du code
        					au moment de la compilation <i>via</i> un processeur d'annotations.</p>
        				</article>
        			</section>
        			<section>
        				<article>
							<figure>
								<figcaption>Une déclaration d'annotation</figcaption>
								<pre><code class="java" data-trim>
public @interface MyAnnotation {
}
								</code></pre>
							</figure>
							<figure>
								<figcaption>Une déclaration d'annotation avec attributs</figcaption>
								<pre><code class="java" data-trim>
public @interface MyAnnotation {
  String  name();
  boolean isOk();
  int[]   range() default {1, 2, 3};
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
							<p>Une annotation implémente implicitement 
							<a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html">Annotation</a> et rien d'autre !</p> 
							<p>Les attributs d'une annotation peuvent être uniquement :</p> 
							<ul>
								<li>Un type primitif,</li> 
								<li>une chaîne de caractères (java.lang.String),</li> 
								<li>une référence de classe (java.lang.Class),</li> 
								<li>une Annotation (java.lang.annotation.Annotation),</li> 
								<li>un type énuméré (enum),</li> 
								<li>un tableau à une dimension d'un de ces types.</li>
							</ul>
							<p>Le mot-clé <strong>default</strong> permet de spécifier une valeur d'attribut par défaut.</p>
        				</article>
        			</section>
        			<section>
        				<article>
							<p>Une annotation peut elle-même être annotée. Les annotations d'annotation fournies par Java 7 sont :</p> 
							<ul>
								<li><a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Documented.html">Documented</a></li> 
								<li><a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Inherited.html">Inherited</a></li> 
								<li><a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Retention.html">Retention</a></li> 
								<li><a target="javadoc" href="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Target.html">Target</a></li> 
							</ul>
        				</article>
        			</section>
        			<section>
        				<article>
							<figure>
								<figcaption>Un exemple d'annotation pour un framework xUnit</figcaption>
								<pre><code class="java" data-trim>
package epsi.test;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Désigne une méthode comme étant un test unitaire. 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
public @interface Test {
  String description();
}
								</code></pre>
							</figure>
        				</article>
        			</section>
				</section>
			</div>
		</div>
		

		<script src="assets/reveal.js-2.5.0/lib/js/head.min.js"></script>
		<script src="assets/reveal.js-2.5.0/js/reveal.min.js"></script>

		<script>
		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,
			transition: "linear",

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'assets/reveal.js-2.5.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'assets/reveal.js-2.5.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'assets/reveal.js-2.5.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'assets/reveal.js-2.5.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
		});
		</script>

	</body>
</html>
