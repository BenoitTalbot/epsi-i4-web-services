<!doctype html>
<html lang="fr">

	<head>
		<meta charset="utf-8">
		<title>I4 Web Services</title>
		<meta name="author" content="David Gayerie">

		<link rel="stylesheet" href="cours.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="reveal.js-2.5.0/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal.js-2.5.0/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<nav>
				<script>
					if(/^https?:/.test(window.location)) {
						document.write('<a href="https://github.com/spoonless/epsi-i4-web-services/archive/gh-pages.zip" class="download">Télécharger</a>');
					}
				</script>
			</nav>

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Notions<br/>complémentaires<br/>en Java</h2>
					<small>EPSI I4 Web Services / David Gayerie - 2013-2014</small>
				</section>
				<section>
					<section>
						<article>
							<header>Compilation</header>
							<p>La compilation du code source ne produit pas un binaire mais du <em>bytecode</em></p>
							<figure>
								<figcaption>Le fichier source Hello.java</figcaption>
								<pre><code class="java" data-trim>
public class Hello {
  public static void main(String[] args) {
    System.out.println("hello the world!");
  }
}
								</code></pre>
							</figure>
							<figure>
								<figcaption>Le fichier Hello.class désassemblé avec <em>javap</em></figcaption>
								<pre><code class="java" data-trim>
public class Hello {
  public static void main(java.lang.String[]);
    Signature: ([Ljava/lang/String;)V
    Code:
       0: getstatic     #16
       3: ldc           #22
       5: invokevirtual #24
       8: return        
}
								</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Le bytecode est exécutable dans une machine virtuelle Java (JVM)</p>
							<figure>
								<figcaption>Le fichier source Hello.java</figcaption>
								<pre><code class="java" data-trim>
public class Hello {
  public static void main(String[] args) {
    System.out.println("hello the world!");
  }
}
								</code></pre>
							</figure>
							<figure>
								<figcaption>Compilation du fichier Hello.java</figcaption>
								<pre><code class="bash">$ javac Hello.java</code></pre>
							</figure>
							<figure>
								<figcaption>Exécution de la classe Hello</figcaption>
								<pre><code class="bash" data-trim>
$ java Hello
hello the world!
								</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<p>Conséquence : Un programme est portable sur un système disposant d'une machine virtuelle Java.</p>
						<blockquote>Compile once, run anywhere</blockquote>
					</section>
				</section>

				<section>
					<section>
						<article>
							<header>Édition de lien</header>
							<p>Java utilise un système de <strong>lien dynamique à l'exécution</strong> (dynamic link).</p>
							<p>Un programme Java est une collection de fichiers .class parfois rassemblés dans une archive (i.e. fichier .jar).</p>
							<p>L'édition de lien se fait au chargement d'un fichier .class dans la JVM. 
							Le <em><strong>ClassLoader</strong></em> a la responsabilité de charger les classes manquantes.</p>
							<p>Le <em>ClassLoader</em> est accessible programmatiquement.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Étant donné deux classes <code>Spaceship</code> et <code>Engine</code></p>
							<figure>
								<figcaption>Spaceship.java</figcaption>
								<pre><code class="java" data-trim>
public class Spaceship {
  private Engine engine = new Engine();

  public void takeoff() {
    engine.startup();
  }
}
								</code></pre>
								<figcaption>Engine.java</figcaption>
								<pre><code class="java" data-trim>
public class Engine {
  public void startup() {
    // ...
  }
}
								</code></pre>
							</figure>
							<p>Une référence à la classe <code>Spaceship</code> dans un programme entraînera 
							son chargement par le <em>ClassLoader</em>. La classe <code>Engine</code> 
							sera également chargée car elle est nécessaire au fonctionnement de <code>Spaceship</code>.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Si une classe ne peut pas être trouvée, on obtient l'erreur <code>NoClassDefFoundError</code> <strong>à l'exécution</strong>.</p>
							<figure>
								<figcaption>Erreur à l'exécution lorsque la classe <code>Engine</code> n'est pas trouvable</figcaption>
								<pre><code class="java" data-trim>
Exception in thread "main" java.lang.NoClassDefFoundError: Engine
        at Spaceship.&lt;init&gt;(Spaceship.java:2)
Caused by: java.lang.ClassNotFoundException: Engine
        at java.net.URLClassLoader$1.run(URLClassLoader.java:202)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
        ... 2 more
								</code></pre>
							</figure>
						</article>
        			</section>
        			<section>
        				<article>
        					<p>Le <em>ClassLoader</em> par défaut de la JVM charge les classes à partir des fichiers .class.</p>
        					<p>L'ensemble des répertoires et des archives contenant les <em>packages</em> et les fichiers .class est appelé le <strong>classpath</strong>.</p>
							<figure>
								<figcaption>Lancement d'un programme sous *NIX en spécifiant le classpath</figcaption>
								<pre><code class="bash" data-trim>java -classpath .:spaceship/bin:lib/galaxy.jar SpaceBattle</code></pre>
							</figure>
							<figure>
								<figcaption>Lancement d'un programme sous Windows en spécifiant le classpath</figcaption>
								<pre><code class="dos" data-trim>java -classpath .;spaceship/bin;lib/galaxy.jar SpaceBattle</code></pre>
							</figure>
							<p>A noter : le séparateur pour le paramètre classpath est différent selon les OS ':' sous *NIX et ';' sous Windows.</p>
        				</article>
        			</section>
        		</section>


        		<section>
        			<section>
        				<article>
        					<header>Les packages</header>
        					<p>Afin d'éviter la collision de nom (des classes, interfaces, énumérations ou annotations portant le même nom),
        					Java supporte la notion de packages.</p>
        					<p>Un package est simplement un répertoire dans lequel sont placés les fichiers Java.</p>
        					<p>Un package définit un espace de nom commun à l'ensemble des éléments de ce package.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Le package d'un fichier source doit être la première instruction du fichier. 
        					Il est spécifié avec le mot-clé <strong>package</strong>.<p>
        					<pre><code class="java" data-trim>
package com.battleship;

public class Spaceship {

  // ...

}
        					</code></pre>
        					<p>Le fichier source doit se trouver dans le répertoire </p>
        					<pre><code class="dos" data-trim>com/battleship</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Pour référencer la classe <code>Spaceship</code> dans un autre fichier source, on peut :</p>
        					<ul>
        						<li>Soit utiliser son nom complet (c'est-à-dire en incluant le package) :
        							<pre><code class="java" data-trim>com.battleship.Spaceship spaceship = new com.battleship.Spaceship();</code></pre>
        						</li>
        						<li>Soit inclure la classe dans l'espace de noms courant avec l'instruction <strong>import</strong> en début de fichier :
        							<pre><code class="java" data-trim>import com.battleship.Spaceship;</code></pre>
        							On peut alors écrire
        							<pre><code class="java" data-trim>Spaceship spaceship = new Spaceship();</code></pre>
        						</li>
        					</ul> 
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>La mot-clé <strong>import</strong> permet aussi d'inclure la totalité des éléments
        					d'un package en utilisant * :</p>
        					<pre><code class="java" data-trim>import com.battleship.*;</code></pre>
        					<p>Il n'est pas nécessaire d'importer un élément qui se trouve dans le même package.</p>
        					<p>Les éléments appartenant au package <strong>java.lang</strong> (comme la classe <code>String</code> par exemple)
        					sont implicitement importés.</p>
        					<p>Par convention, le nom des packages s'écrit en minuscules.</p>
        					<p>Les packages commençant par <strong>java</strong> ou <strong>javax</strong> sont réservés.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Il est également possible d'importer les éléments <strong>static</strong> d'une classe.<p>
        					<p>Cela permet d'invoquer des méthodes ou de référencer les attributs sans avoir à les préfixer par le nom de la classe.</p>
							<figure>
								<pre><code class="java" data-trim>
class Angle {
  private double radianAngle;

  public Angle(double radianAngle) {
    this.radianAngle = Math.max(0d, radianAngle);
    this.radianAngle = Math.min(2 * Math.PI, this.radianAngle);
  }
}
								</code></pre>
								<pre><code class="java" data-trim>
import static java.lang.Math.*;

class Angle {
  private double radianAngle;

  public Angle(double radianAngle) {
    this.radianAngle = max(0d, radianAngle);
    this.radianAngle = min(2 * PI, this.radianAngle);
  }
}
								</code></pre>
							</figure>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Un package peut contenir un fichier spécial : <strong>package-info.java</strong></p>
        					<p>Ce fichier contient obligatoirement l'instruction <strong>package</strong> comme pour un fichier normal.</p>
        					<p>De plus, il peut contenir la documentation du package mais également des annotations de niveau package.</p>
							<figure>
								<figcaption>Exemple d'un fichier package-info.java</figcaption>
									<pre><code class="java" data-trim>
/**
 * La javadoc du package vient ici...
 */
@javax.xml.bind.annotation.XmlSchema
(namespace = "http://www.epsi.fr/i4-web-services/myfirstwebservice")
package fr.epsi.i4_web_services.myfirstwebservice;
								</code></pre>
							</figure>
        				</article>
        			</section>
				</section>

        		<section>
        			<section>
        				<article>
        					<header>Les exceptions</header>
        					<p>Une exception permet d'interrompre un traitement lorsqu'une situation exceptionnelle se produit.</p>
        					<p>Une exception est propagée dans la pile des appels de méthodes. 
        					Elle peut être interceptée progammatiquement.</p>
        					<p>Si elle n'est interceptée par aucune méthode, elle remonte la pile d'appel et interrompt le tread d'exécution.</p>
        					<p>S'il s'agit du thread principal, le programme s'interrompt en erreur.</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Les exceptions sont représentées par des classes qui ont comme ancêtre <strong>java.lang.Throwable</strong></p>
							<figure>
								<figcaption>La hiérarchie de base des exceptions</figcaption>
								<img src="assets/images/exception_inheritance.png"/>
							</figure>
        					<p>Les classes héritant de <strong>java.lang.Error</strong> sont réservées pour la JVM afin de signaler des erreurs systèmes :</p>
        					<ul>
        						<li>NoClassDefFoundError</li>
        						<li>OutOfMemoryError</li>
        						<li>StackOverflowError</li>
        						<li>...</li>
        					</ul>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Pour lancer une exception on utilise le mot-clé <strong>throw</strong>.</p>
							<pre><code class="java" data-trim>
// La classe hérite de exception qui hérite elle-même de throwable.
// Par convention le nom de la classe se termine par Exception.
public class EndOfTheWorldException extends Exception {
}
							</code></pre>
							<p>On peut maintenant signaler l'événement exceptionnel de la fin du monde en lançant l'exception :</p>
							<pre><code class="java" data-trim>
throw new EndOfTheWorldException();
							</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>On distingue deux catégories d'exception :</p>
        					<ul>
        						<li>Les <em>checked exceptions</em> apparaissent dans la signature des méthodes qui peuvent
        						les lancer ou les propager lors d'un appel grâce au mot-clé <strong>throws</strong>.
									<pre><code class="java" data-trim>
public void pressTheRedButton() throws EndOfTheWorldException {
  if(this.isTheEndOfTheWorld()) {
    throw new EndOfTheWorldException();
  }
  // ...
}

public void doSomethingSilly() throws EndOfTheWorldException {
  pressTheRedButton();
}
									</code></pre>
									<p>Plusieurs <em>checked exceptions</em> peuvent être spécifiées en les séparant par une virgule :</p>
									<pre><code class="java" data-trim>
public Stuff buy(long amount, Currency currency) 
  throws NotEnoughMoneyException, NotAcceptedCurrencyException, 
         StuffUnavailableException {
  // ...
}
									</code></pre>
								</li>
							</ul>
        				</article>
        			</section>
        			<section>
        				<article>
        					<ul>
        						<li>Les <em>unchecked exceptions</em> héritent directement ou indirectement 
        						de <strong>RuntimeException</strong> ou de <strong>Error</strong>.
        						<p>La déclaration de ces exceptions est <strong>optionnelle</strong> 
        						dans la signature des méthodes pouvant les lancer ou les propager.</p>
									<pre><code class="java" data-trim>
public class EntityNotFoundException extends RuntimeException {
  public EntityNotFoundException(String message) {
    super(message);
  } 
}
									</code></pre>
									<pre><code class="java" data-trim>
// Il n'est pas nécessaire d'ajouter :
//       throws EntityNotFoundException
// car EntityNotFoundException hérite de RuntimeException.
public Entity get(String id) {
  Entity entity = database.load(id);
  if (entity == null) {
    throw new EntityNotFoundException("Cannot find entity " + id);
  }
  return entity;
}
									</code></pre>
								</li>
							</ul>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Une exception peut être interceptée par une méthode dans la pile d'appel :</p>
							<pre><code class="java" data-trim>
try {
  evilMind.pressTheRedButton();
}
catch (EndOfTheWorldException ex) {
  hero.saveTheWorld();
}
							</code></pre>
        					<p>Le block défini par le mot-clé <strong>catch</strong> est exécuté <strong>uniquement</strong>
        					si une exception de type <strong>EndOfTheWorldException</strong> est lancée lors de l'exécution
        					du block défini par le mot-clé <strong>try</strong>.
        					</p>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Un block défini par le mot-clé <strong>finally</strong> est exécuté systématiquement après un block
        					<strong>try</strong> et un block <strong>catch</strong> (si une exception a été attrapée).</p>
							<pre><code class="java" data-trim>
try {
  evilMind.pressTheRedButton();
}
catch (EndOfTheWorldException ex) {
  hero.saveTheWorld();
}
finally {
  // Finalement, le héros arrête l'esprit du mal qu'il ait eu
  // ou non à sauver le monde.
  hero.arrest(evilMind);
}
							</code></pre>
        				</article>
        			</section>
        			<section>
        				<article>
        					<p>Un block <strong>finally</strong> est souvent utilisé en Java pour libérer 
        					des ressources système à la fin d'un traitement.</p>
							<pre><code class="java" data-trim>
public String getFileContent(String filename) throws java.io.IOException {
  java.io.FileReader reader = new java.io.FileReader(filename);
  try {
    int nbCharRead = 0;
    char[] buffer = new char[1024];
    StringBuilder builder = new StringBuilder();
    // L'appel à reader.read peut lancer une java.io.IOException
    while ((nbCharRead = reader.read(buffer)) &gt;= 0) {
      builder.append(buffer, 0, nbCharRead);
    }
    // le retour explicite n'empêche pas l'exécution du block finally.
    return builder.toString();
  }
  // Ce block est obligatoirement exécuté après le block try.
  // Ainsi le flux de lecture sur le fichier est fermé 
  // avant le retour de la méthode. 
  finally {
    reader.close();
  }
}
							</code></pre>
        				</article>
        			</section>
				</section>

        		<section>
        			<section>
        				<article>
        					<header>Les interfaces</header>
        				</article>
        			</section>
				</section>
        		<section>
        			<section>
        				<article>
        					<header>La synchronisation</header>
        				</article>
        			</section>
				</section>
        		<section>
        			<section>
        				<article>
        					<header>La sérialisation</header>
        				</article>
        			</section>
				</section>
        		<section>
        			<section>
        				<article>
        					<header>Les annotations</header>
        				</article>
        			</section>
				</section>
        		<section>
        			<section>
        				<article>
        					<header>Les JavaBeans</header>
        				</article>
        			</section>
				</section>
			</div>
		</div>
		

		<script src="reveal.js-2.5.0/lib/js/head.min.js"></script>
		<script src="reveal.js-2.5.0/js/reveal.min.js"></script>

		<script>
		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,
			transition: "linear",

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'reveal.js-2.5.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'reveal.js-2.5.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'reveal.js-2.5.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'reveal.js-2.5.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
		});
		</script>

	</body>
</html>
