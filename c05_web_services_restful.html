<!doctype html>
<html lang="fr">

	<head>
		<meta charset="utf-8">
		<title>I4 Web Services</title>
		<meta name="author" content="David Gayerie">

		<link rel="stylesheet" href="assets/cours.css">
		<link rel="stylesheet" href="assets/cours-paper.css" media="print">

		<!--[if lt IE 9]>
		<script src="assets/reveal.js-2.5.0/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<nav>
				<script>
					if( /^https?:/.test(window.location)) {
						document.write('<a href="https://github.com/spoonless/epsi-i4-web-services/archive/gh-pages.zip" class="download">Télécharger</a>');
					}
				</script>
			</nav>

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section class="title">
					<h1>Web Services RESTful</h1>
					<p class="copyright">EPSI I4 Web Services / <a class="explicit" href="mailto:david.gayerie.epsi@mailoo.org">David Gayerie</a> - 2013-2014</p>
				</section>
				<section>
					<section>
						<article>
							<header>REST</header>
							<p>REST est un style d'architecture pour les systèmes hypermédia distribués.</p>
							<p>Une implémentation qui se conforme à REST est dite <em>RESTful</em>.</p>
							<p>En 2000, Roy Fielding a formalisé l'architecture REST dans le chapitre 5 de sa <a target="_blank" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm">thèse</a>.</p>
							<p>En 2007, Leonard Richardson et Sam Ruby présentent ROA (Resource Oriented Architecture) dans leur ouvrage <em>RESTful Web Services</em>.
							ROA va devenir le modèle d'application de REST pour les Web services.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Depuis quelques années, REST et RESTful sont devenus des buzzwords :(</p>
						</article>
					</section>
					<section data-background="#FA5858">
						<p>Idée fausse : Je développe des Web Services RESTful car j'utilise un framework REST (comme JAX-RS).</p>
					</section>
					<section>
						<p>La première chose à retenir :<br>
						REST est le modèle d'architecture du Web !</p>
					</section>
					<section>
						<article>
							<p>Un Web service RESTful suit les mêmes principes qu'un site Web pour les humains.</p>
							<p>La différence principale tient au fait que la sémantique des données échangées <i>via</i>
							le Web service est compréhensible par un programme (Web programmable).</p>
							<p>Un Web service RESTful devrait être conçu comme un site Web (et réciproquement).</p>
						</article>
					</section>
					<section>
						<article>
							<p>Domaines principaux d'application des Web services RESTful :</p>
							<ul>
								<li>Applications Web riches (Ajax)</li>
								<li>Applications pour Mobile</li>
								<li>Le Web des objets</li>
								<li>L'open data</li>
							</ul>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>La ressource</header>
							<p>REST est un style d'architecture <strong>orienté ressource</strong>.</p>
							<p>Qu'est-ce qu'une ressource ?</p>
							<blockquote>
								<span>Any information that can be named can be a resource</span>
								<footer>Roy Fielding</footer>
							</blockquote>
						</article>
					</section>
					<section>
						<article>
							<p>Dans le domaine de Web :</p>
							<pre><code>Information nommée = Information adressable</code></pre>
							<pre><code>Adressable = URI (Uniform Resource Identifier)</code></pre>
							<p>Une ressource Web est une donnée adressable par une ou plusieurs URI.</p>
							<p>Exemple : ce cours est adressable à partir de l'URI <a href="http://spoonless.github.io/epsi-i4-web-services" class="explicit">http://spoonless.github.io/epsi-i4-web-services</a></p>
						</article>
					</section>
					<section>
						<article>
							<p>Une ressource de Web service peut être accessible à partir de plusieurs URI. Une bonne pratique consiste à considérer qu'une des URI est l'URI "canonique".</p>
							<p>Exemple d'un service pour connaître la liste des étudiants :</p>
							<pre><code class="http">http://epsi.fr/bordeaux/informatique/i4/etudiants/2014 (URI canonique)</code></pre>
							<pre><code class="http">http://epsi.fr/bordeaux/informatique/i4/etudiants/annee-courante</code></pre>
							<p>Ces deux URI désignent la même ressource pendant une période.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Le serveur peut rediriger le client vers l'URI "canonique".</p>
							<figure>
								<figcaption>Canonicalisation par redirection</figcaption>
								<pre><code class="http">GET /bordeaux/informatique/i4/etudiants/annee-courante HTTP/1.1
Host: epsi.fr
								</code></pre>
								<pre><code class="http">HTTP/1.1 303 See Other
Location: http://epsi.fr/bordeaux/informatique/i4/etudiants/2014

</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Le serveur peut simplement informer le client qu'il existe une URI "canonique" grâce à l'en-tête <em>Content-location</em> dans la réponse.</p>
							<figure>
								<figcaption>Canonicalisation par lien</figcaption>
								<pre><code class="http">GET /bordeaux/informatique/i4/etudiants/annee-courante HTTP/1.1
Host: epsi.fr
								</code></pre>
								<pre><code class="http">HTTP/1.1 200 OK
Content-location: http://epsi.fr/bordeaux/informatique/i4/etudiants/2014
Content-type: application/xml; charset=utf-8
Content-length: 436

&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;etudiants&gt;
  ...
&lt;/etudiants&gt;</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Une bonne pratique est de définir des URI descriptives et hiérarchiques</p>
							<pre><code class="http">http://epsi.fr/bordeaux/informatique/i4/etudiants/2014</code></pre>
							<p>Cette URI suit un pattern facilement compréhensible :</p>
							<pre><code class="http">http://epsi.fr/{ville}/{spécialité}/{code année}/etudiants/{promotion}</code></pre>
							<p>Des URIs bien conçues facilitent l'utilisation des services.</p>
						</article>
					</section>
					<section>
						<article>
							<p>REST ne doit pas être confondu avec une autre approche de système distribué : le RPC (Remote Procedure Call)</p>
							<p>Les services RPC exposent des procédures et sont <strong>orientés traitement</strong>. Le client envoie des paramètres et demande au serveur de lui retourner un résultat.</p>
							<p>Les URI des Web services RPC se terminent souvent par des verbes.</p>
						</article>
					</section>
					<section data-background="#FA5858">
						<article>
							<p>Idée fausse : Je développe des Web Services RESTful car mes services sont chacuns accessibles <i>via</i> une URI.</p>
							<p>Exemple d'URI non RESTful:</p>
							<pre><code class="http">http://mon.site.com/article147/delete</code></pre>
							<pre><code class="http">http://mon.site.fr/data?ressource=ma+ressource</code></pre>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>La représentation</header>
							<p>Dans une architecture REST, un client et un serveur n'échangent pas une ressource 
							mais une représentation, c'est-à-dire <em>un ensemble de données relatives à l'état courant d'une ressource</em>.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Une même ressource Web peut avoir plusieurs représentations : une image JPEG, une page HTML, un document XML, un document JSON...</p>
							<p>Un serveur peut choisir la représentation de la ressource pour correspondre au mieux aux capacités du client : on parle de négociation de contenu.</p>
						</article>
					</section>
					<section>
						<article>
							<p>La négociation de contenu peut se faire grâce à l'en-tête <em>Accept</em> dans la requête</p>
							<figure>
								<figcaption>Négociation de contenu par en-tête</figcaption>
								<pre><code class="http">GET /bordeaux/informatique/i4/etudiants/2014 HTTP/1.1
Host: epsi.fr
Accept: image/jpeg, application/json, */*
								</code></pre>
								<pre><code class="http">HTTP/1.1 200 OK
Content-type: application/json; charset=utf-8
Content-length: 350

{
  ...
}</code></pre>
							</figure>
							<p>Si le serveur ne peut fournir une représentation acceptable par le client, il peut répondre le code erreur 415 "Unsupported Media Type".</p>
						</article>
					</section>
					<section>
						<article>
							<p>La négociation de contenu peut se faire avec l'extension utilisée dans le chemin de la ressource.</p>
							<figure>
								<figcaption>Négociation de contenu par extension</figcaption>
								<pre><code class="http">GET /bordeaux/informatique/i4/etudiants/2014.json HTTP/1.1
Host: epsi.fr
								</code></pre>
								<pre><code class="http">HTTP/1.1 200 OK
Content-type: application/json; charset=utf-8
Content-length: 350

{
  ...
}</code></pre>
							</figure>
						</article>
					</section>
					<section data-background="#FA5858">
						<article>
							<p>Idée fausse : Je développe des Web Services RESTful car mon serveur retourne du JSON (ou XML (ou YAML (ou ATOM))).</p>
						</article>
					</section>
					<section>
						<article>
							<p>Pour Java EE, avec JAX-RS, le format de la représentation est géré par les annotations</p>
							<dl>
								<dt><a href="http://docs.oracle.com/javaee/6/api/javax/ws/rs/Consumes.html" target="_blank">@Consumes</a></dt>
								<dd>Indique les types MIME du corps de la requête que peut accepter une méthode</dd>
								<dt><a href="http://docs.oracle.com/javaee/6/api/javax/ws/rs/Produces.html" target="_blank">@Produces</a></dt>
								<dd>Indique les types MIME du corps de la réponse que peut produire une méthode</dd>
							</dl>
							<p>JAX-RS inclut un <a href="http://docs.oracle.com/javaee/6/tutorial/doc/gkknj.html" target="_blank">binding</a>
							entre les classes Java et les types MIME application/xml, application/json grâce aux annotations JAXB.</p>
						</article>
					</section>
					<section>
						<article>
							<figure>
								<figcaption>Utilisation des annotations @Consumes et @Produces :</figcaption>
								<pre><code class="java">
  @PUT
  @Path("{id}")
  @Consumes({ "application/json", "application/xml" })
  public void merge(@PathParam("id") String id, MyRepresentation rep) {
    // ...
  }

  @GET
  @Path("{id}")
  @Produces({ "application/json", "application/xml" })
  public MyRepresentation get(@PathParam("id") String id) {
    // ...
  }
								</code></pre>
							</figure>
							<figure>
								<figcaption>Utilisation du binding JAXB sur la représentation</figcaption>

								<pre><code class="java">
@XmlRootElement
public class MyRepresentation {
  // ...
}
								</code></pre>
							</figure>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>Les contraintes REST</header>
							<ul>
								<li>client/serveur</li>
								<li>interface uniforme (uniform interface)</li>
								<li>sans état (stateless)</li>
								<li>mise en cache</li>
								<li>layered system</li>
								<li>code-on-demand</li>
							</ul>
						</article>
					</section>
					<section>
						<article>
							<dl>
								<dt>client/serveur</dt>
								<dd>
									<p>L'architecture <a href="http://en.wikipedia.org/wiki/Client_server" target="wiki">Client/Serveur</a>
									 est une architecture logique centralisée pour le développement d'applications distribuées.</p> 
									 <p>Un programme serveur se met en attente de requêtes de programmes clients vers lesquels il retourne
									 une réponse.</p>

									 <dl>
									 	<dt>Web</dt>
									 	<dd>Le Web est en grande partie conçu à partir de cette contrainte. HTTP est un protocole élaboré à partir du modèle client/serveur.</dd>
									 </dl>
									 
									 <dl>
									 	<dt>JAX-RS</dt>
									 	<dd>JAX-RS repose sur le conteneur Web Java EE pour rendre les services accessibles en HTTP.</dd>
									 </dl>
								</dd>
							</dl>
						</article>
					</section>
					<section>
						<article>
							<dl>
								<dt>interface uniforme (uniform interface)</dt>
								<dd>
									<p>Les composants d'une architecture REST doivent utiliser une interface uniforme.
									Limiter l'interface permet de conserver une architecture simplifiée (plus simple à comprendre et plus simple à faire évoluer).
									</p>
									<dl>
										<dt>Web</dt>
										<dd>L'interface est contrainte par la méthode HTTP, l'URI et le content-type</dd>
									</dl>
									
									<dl>
										<dt>JAX-RS</dt>
										<dd>Associe une méthode Java à une méthode HTTP (@GET, @POST, ...), au chemin de ressource (@Path)
										et au content-type de la requête (@Consumes) et de la réponse (@Produces).</dd>
									</dl>
								</dd>
							</dl>
						</article>
					</section>
					<section>
						<article>
							<dl>
								<dt>sans état (stateless)</dt>
								<dd>
									<p>Une requête doit contenir l'ensemble de l'information nécessaire à son traitement.
									Chaque requête est donc "sans mémoire" (indépendantes de l'ordre des requêtes précédentes).
									Les informations de session sont conservées uniquement par l'application cliente.</p>
									<p>Le respect de cette contrainte permet de construire des architectures plus sûres et plus scalables.</p>

									 <dl>
									 	<dt>Web</dt>
									 	<dd>Il existe des techniques très largement répandues qui enfreignent cette contrainte : utilisation des cookies pour identifier une session utilisateur temporaire sur le serveur.</dd>
									 </dl>
									 
									 <dl>
									 	<dt>JAX-RS</dt>
									 	<dd>JAX-RS est une API sans état. Il est néanmoins possible de développer des applications Web Java EE avec état (stateful).</dd>
									 </dl>
								</dd>
							</dl>
						</article>
					</section>
					<section>
						<article>
							<dl>
								<dt>mise en cache</dt>
								<dd><p>La mise en cache est nécessaire pour améliorer l'efficacité des échanges réseaux. Cela implique que la représentation
								d'une ressource doit pouvoir indiquée si elle peut être mise en cache par le client ou un système intermédiare.
								</p>
									<dl>
										<dt>Web</dt>
										<dd>Le Web dispose de multiple composants pour la mise en cache (navigateurs Web, proxies...). De plus HTTP supporte
										la définition des stratégies de cache et les requêtes conditionnelles grâce aux en-têtes 
										<a href="http://fr.wikipedia.org/wiki/Cache-Control" target="_blank">Cache-control</a>, <a href="http://en.wikipedia.org/wiki/HTTP_ETag" target="_blank">ETag</a>, <a href="http://en.wikipedia.org/wiki/HTTP_ETag" target="_blank">If-None-Match</a>, If-Modified-Since.
										</dd>
									</dl>
									
									<dl>
										<dt>JAX-RS</dt>
										<dd>JAX-RS intègre l'évaluation des préconditions d'une requête HTTP grâce aux méthodes <a href="http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/Request.html" target="_blank">Request.evaluatePreconditions()</a>
										</dd>
									</dl>
								</dd>
							</dl>
						</article>
					</section>
					<section>
						<figure>
							<figcaption>Gestion des préconditions avec JAX-RS</figcaption>
							<pre><code class="java" data-trim>
@Path("/bill/{ref}")
@GET
public Response getBill(@PathParam("ref") String ref, @Context Request req){

  Bill bill = billRepository.get(ref);

  EntityTag etag = new EntityTag(Integer.toString(bill.hashCode()));
  
  ResponseBuilder builder = req.evaluatePreconditions(etag);

  // Si la précondition échoue, builder sera null
  if(builder == null){
    // L'etag n'est pas celui transmis par le client 
    // (ou le client n'en a pas fourni), il faut retourner les données.
    builder = Response.ok(bill);
    
    // On retourne l'Etag au client
    builder.tag(etag);
  }

  return builder.build();
}
							</code></pre>
						</figure>
					</section>
					<section>
						<article>
							<dl>
								<dt>layered system</dt>
								<dd>Une architecture REST doit être composée en couches hiérarchiques.
								Un composant ne peut dialoguer qu'avec ses voisins immédiats, c'est-à-dire les composants
								appartenant aux couches adjacentes. Cette contrainte permet d'éviter un système centralisé et favorise
								les techniques de mise en cache et de load balancing. 
									 <dl>
									 	<dt>Web</dt>
									 	<dd>Le Web est largement conçu selon cette contrainte. Des composants spécialisés comme les proxy
									 	et les firewalls permettent de renforcer une architecture en couche.</dd>
									 </dl>
									 
									 <dl>
									 	<dt>JAX-RS</dt>
									 	<dd>Cette contrainte n'a pas de répercussion sur l'API JAX-RS.</dd>
									 </dl>
								</dd>
							</dl>
						</article>
					</section>
					<section>
						<article>
							<dl>
								<dt>code-on-demand</dt>
								<dd>Il s'agit d'une contrainte optionnelle de l'architecture REST. 
								Un client peut étendre ses fonctionnalités en téléchargeant du code exécutable.								
									 <dl>
									 	<dt>Web</dt>
									 	<dd>Le code-on-demand est trés largement utilisé dans le Web pour les humains 
									 	avec en particulier le support de JavaScript pour étendre les fonctionnalités du navigateur Web.</dd>
									 </dl>
									 
									 <dl>
									 	<dt>JAX-RS</dt>
									 	<dd>Cette contrainte n'est présente dans l'API JAX-RS. Cependant, elle peut être implémentée facilement
									 	grâce au <a href="http://docs.oracle.com/javaee/6/api/javax/ws/rs/ext/MessageBodyWriter.html" target="_blank">MessageBodyWriter</a>.</dd>
									 </dl>
								</dd>
							</dl>
						</article>
					</section>
				</section>
				<section>
					<article>
						<header>HATEOAS</header>
						<p>Dans sa thèse, Roy Fielding cite une contrainte de l'interface uniforme :</p>
						<blockquote>
							<span>hypermedia as the engine of application state</span>
						</blockquote>
						<p>Cette contrainte est couramment abrégée en HATEOAS. Mais que signifie-t-elle ?</p>
					</article>
				</section>
				<section>
					<section>
						<article>
							<header>Exemple : Paiement de factures</header>
							<figure>
								<figcaption>Activité d'un système de paiement de factures</figcaption>
								<img src="assets/images/diagramme_activite_paiement_facture.svg" >
							</figure>
							<p>Comment modéliser un système de paiement de factures RESTful ?</p>
						</article>
					</section>
					<section>
						<figure>
							<figcaption>Création d'une facture</figcaption>
							<pre><code class="http">PUT /utilisateur/moi/facture/fact-2013005689 HTTP/1.1
Host: facture-en-ligne.fr
Content-type: application/x-www-form-urlencoded; charset=utf-8
[...]

montant=2100&amp;client=MonClient</code></pre>
							<pre><code class="http">HTTP/1.1 201 CREATED
[...]

</code></pre>
						</figure>
					</section>
					<section>
						<figure>
							<figcaption>Modification d'une facture</figcaption>
							<pre><code class="http">PUT /utilisateur/moi/facture/fact-2013005689 HTTP/1.1
Host: facture-en-ligne.fr
Content-type: application/x-www-form-urlencoded; charset=utf-8
[...]

montant=2300&amp;client=MonClient</code></pre>
							<pre><code class="http">HTTP/1.1 200 OK
[...]

</code></pre>
						</figure>
					</section>
					<section>
						<figure>
							<figcaption>Consultation d'une facture (XML avec négociation de contenu)</figcaption>
							<pre><code class="http">GET /utilisateur/moi/facture/fact-2013005689 HTTP/1.1
Host: facture-en-ligne.fr
Accept: application/xml
[...]

</code></pre>
							<pre><code class="http">HTTP/1.1 200 OK
Content-type: application/xml; charset=utf-8
[...]

&lt;?xml version="1.0" ?&gt;
&lt;facture&gt;
  &lt;reference&gt;fact-2013005689&lt;/reference&gt;
  &lt;client&gt;MonClient&lt;/client&gt;
  &lt;montant&gt;2300&lt;/montant&gt;
  &lt;date&gt;2013-11-01T18:30:10Z&lt;/date&gt;
&lt;/facture&gt;</code></pre>
						</figure>
					</section>
					<section>
						<figure>
							<figcaption>Consultation d'une facture (JSON avec négociation de contenu)</figcaption>
							<pre><code class="http">GET /utilisateur/moi/facture/fact-2013005689 HTTP/1.1
Host: facture-en-ligne.fr
Accept: application/json
[...]

</code></pre>
							<pre><code class="http">HTTP/1.1 200 OK
Content-type: application/json; charset=utf-8
[...]

{'reference':'fact-2013005689', 
 'montant':2300, 
 'client':'MonClient', 
 'date':'2013-11-01T18:30:10Z'}</code></pre>
						</figure>
					</section>
					<section>
						<figure>
							<figcaption>Création d'une autorisation de paiement</figcaption>
							<pre><code class="http">POST /utilisateur/moi/facture/fact-2013005689/autorisation HTTP/1.1
Host: facture-en-ligne.fr
Content-type: application/json
[...]

{'cardOwner':'', 
 'cardNumber':'1111222233334444', 
 'cardExpiryDate':'122014', 
 'cardSecurityNumber':'123'}</code></pre>
							<pre><code class="http">HTTP/1.1 201 CREATED
Location: http://facture-en-ligne.fr/utilisateur/moi/facture/fact-2013005689/autorisation/3F2504E0
[...]

</code></pre>
						</figure>
					</section>
					<section>
						<figure>
							<figcaption>Modification d'une facture après autorisation</figcaption>
							<pre><code class="http">PUT /utilisateur/moi/facture/fact-2013005689 HTTP/1.1
Host: facture-en-ligne.fr
Content-type: application/x-www-form-urlencoded; charset=utf-8
[...]

montant=2312&amp;client=MonClient</code></pre>
							<pre><code class="http">HTTP/1.1 409 CONFLICT
Content-type: plain/text; charset=utf-8
[...]

La facture fact-2013005689 ne peut pas être modifiée car une autorisation 
de paiement a déjà été effectuée avec succès.</code></pre>
						</figure>
						<p>En fonction de l'état des resources, certaines opérations peuvent ne plus être possibles et entraîner un rejet pour conflit.</p>
					</section>
				</section>
				<section>
					<h2>REST = Representational State Transfer</h2>
				</section>
			</div>

		</div>

		<script src="assets/reveal.js-2.5.0/lib/js/head.min.js"></script>
		<script src="assets/reveal.js-2.5.0/js/reveal.min.js"></script>

		<script>
		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,
			transition: "linear",

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'assets/reveal.js-2.5.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'assets/reveal.js-2.5.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'assets/reveal.js-2.5.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'assets/reveal.js-2.5.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
		});
		</script>

	</body>
</html>
