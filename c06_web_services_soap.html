<!doctype html>
<html lang="fr">

	<head>
		<meta charset="utf-8">
		<title>I4 Web Services</title>
		<meta name="author" content="David Gayerie">

		<link rel="stylesheet" href="assets/cours.css">
		<link rel="stylesheet" href="assets/cours-paper.css" media="print">

		<!--[if lt IE 9]>
		<script src="assets/reveal.js-2.5.0/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<nav>
				<script>
					if( /^https?:/.test(window.location)) {
						document.write('<a href="https://github.com/spoonless/epsi-i4-web-services/archive/gh-pages.zip" class="download">Télécharger</a>');
					}
				</script>
			</nav>

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section class="title">
					<h1>Web Services SOAP</h1>
					<p class="copyright">EPSI I4 Web Services / <a class="explicit" href="mailto:david.gayerie.epsi@mailoo.org">David Gayerie</a> - 2013-2014</p>
				</section>
				<section>
					<section>
						<article>
							<header>La quête de l'interopérabilité</header>
							<!-- Finir en disant que SOAP est une technique basée sur XML (et pas une architecture comme REST) -->
							<p>Comment échanger des informations entre deux processus alors que :</p>
							<ul>
								<li>les programmes sont écrits dans des langages différents</li>
								<li>les processus s'exécutent sur des machines différentes</li>
								<li>les machines appartiennent à des réseaux différents</li>
							</ul>
							<p>Avant l'an 2000, on trouve des solutions telles que Sun RPC, CORBA, DCOM, RMI.</p>
						</article>
					</section>
					<section>
						<article>
							<p>&Agrave; partir des années 2000, le succés des réseaux IP, de HTTP 
							et de XML apporte une nouvelle perspective : définir
							un protocole d'échange de messages XML <i>via</i> HTTP entre deux processus.</p>
							<p>Ce protocole originellement défini par Microsoft puis maintenu par le W3 s'appelle <strong>SOAP</strong>.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Depuis SOAP a été enrichi de nombreuses spécifications et l'ensemble de ces technologies sont désignées sous le terme <strong>WS-*</strong>.</p>
							<p>WS-* est un ensemble de technologies, il ne s'agit ni d'un modèle de conception ni d'un modèle d'architecture.</p>
						</article>
					</section>
					<section>
						<article>
							<figure>
								<figcaption>Exemple de message SOAP</figcaption>
								<pre><code class="xml">&lt;soapenv:Envelope 
   xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
   xmlns:m="http://www.mymeteo.com/webservices/samples"&gt;
   &lt;soapenv:Header&gt;
   &lt;/soapenv:Header&gt;
   &lt;soapenv:Body&gt;
      &lt;m:meteo&gt;
         &lt;m:temperature&gt;12&lt;/m:temperature&gt;
         &lt;m:unite&gt;celsius&lt;/m:unite&gt;
         &lt;m:ville&gt;Bordeaux&lt;/m:ville&gt;
      &lt;/m:meteo&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;</code></pre>
							</figure>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>Un premier service Web SOAP avec JAX-WS</header>
							<p>JAX-WS est l'API Java EE pour l'implémentation de services Web SOAP.</p>
							<p>JAX-WS utilise JAXB pour le binding Java/XML.</p> 
						</article>
					</section>
					<section>
						<article>
							<figure>
								<figcaption>Un premier service Web SOAP</figcaption>
								<pre><code class="java">
import javax.ejb.Stateless;
import javax.jws.WebParam;
import javax.jws.WebService;

//L'annotation Stateless est nécessaire pour TomEE
@Stateless 
@WebService
public class HelloService {
	
  public String sayHello(@WebParam(name="who") String name) {
    return "Hello " + name;
  }

}
								</code></pre>
							</figure>
							<p>Cette classe est appelée la <strong>SEI</strong> (Service Endpoint Implementation).</p>
						</article>
					</section>
					<section>
						<article>
							<figure>
								<figcaption>Une requête au Web service</figcaption>
								<pre><code class="xml">
&lt;soapenv:Envelope 
   xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
   xmlns:i4="http://i4.epsi.fr/"&gt;
   &lt;soapenv:Header/&gt;
   &lt;soapenv:Body&gt;
      &lt;i4:sayHello&gt;
         &lt;who&gt;david&lt;/who&gt;
      &lt;/i4:sayHello&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
								</code></pre>
							</figure>
							<p>Le message doit être envoyé avec la méthode HTTP POST à l'URL du service
							(appelée aussi <strong>endpoint</strong>)</p>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>Parlez-vous XML&nbsp;?</header>
							<p>XML = Extensible Markup Language</p>
							<p>XML est un langage de balisage générique.</p> 
						</article>
					</section>
					<section>
						<article>
							<p>Un document XML est <strong>bien formé</strong> (well-formed) s'il respecte 
							la <a href="http://www.w3.org/TR/xml/" target="_blank">recommandation W3</a>.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Ce document XML est-il bien formé ?</p>
							<pre><code class="xml">
&lt;cours&gt;
  &lt;intitulé&gt;Web services&lt;/intitulé&gt;
  &lt;enseignant&gt;D. Gayerie&lt;/enseignant&gt;
&lt;/cours&gt;
							</code></pre>
							<p class="fragment">Réponse : oui</p>
						</article>
					</section>
					<section>
						<article>
							<p>Ce document XML est-il bien formé ?</p>
							<pre><code class="xml">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;cours&gt;
  &lt;code id="I4WS"&gt;
  &lt;intitulé&gt;Web services&lt;/intitulé&gt;
  &lt;enseignant&gt;D. Gayerie&lt;/enseignant&gt;
&lt;/cours&gt;
							</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Réponse : non</p>
							<p>L'élément code doit être fermé :</p>
							<pre><code class="xml">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;cours&gt;
  &lt;code id="I4WS"/&gt;
  &lt;intitulé&gt;Web services&lt;/intitulé&gt;
  &lt;enseignant&gt;D. Gayerie&lt;/enseignant&gt;
&lt;/cours&gt;
							</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Ce document XML est-il bien formé ?</p>
							<pre><code class="xml">
&lt;cours&gt;
  &lt;intitulé&gt;Génie logiciel&lt;/intitulé&gt;
&lt;/cours&gt;
&lt;cours&gt;
  &lt;intitulé&gt;Web services&lt;/intitulé&gt;
&lt;/cours&gt;
							</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Réponse : non</p>
							<p>Le document doit contenir un seul élément racine :</p>
							<pre><code class="xml">
&lt;programme&gt;
  &lt;cours&gt;
    &lt;intitulé&gt;Génie logiciel&lt;/intitulé&gt;
  &lt;/cours&gt;
  &lt;cours&gt;
    &lt;intitulé&gt;Web services&lt;/intitulé&gt;
  &lt;/cours&gt;
&lt;/programme&gt;
							</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Ce document XML est-il bien formé ?</p>
							<pre><code class="xml">
&lt;programme&gt;
  &lt;cours code=I4GL&gt;
    &lt;intitulé&gt;Génie logiciel&lt;/intitulé&gt;
  &lt;/cours&gt;
  &lt;cours code=I4WS&gt;
    &lt;intitulé&gt;Web services&lt;/intitulé&gt;
  &lt;/cours&gt;
&lt;/programme&gt;
							</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Réponse : non</p>
							<p>Les attributs d'un élément doivent être entre guillemets :</p>
							<pre><code class="xml">
&lt;programme&gt;
  &lt;cours code="I4GL"&gt;
    &lt;intitulé&gt;Génie logiciel&lt;/intitulé&gt;
  &lt;/cours&gt;
  &lt;cours code="I4WS"&gt;
    &lt;intitulé&gt;Web services&lt;/intitulé&gt;
  &lt;/cours&gt;
&lt;/programme&gt;
							</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Ce document XML est-il bien formé ?</p>
							<pre><code class="xml">
&lt;test&gt;
  &lt;question&gt;Ce document est-il valide ?&lt;/question&gt;
  &lt;exemple&gt;
  &lt;![CDATA[
  &lt;document&gt;&lt;/DOCUMENT&gt;
  ]]&gt;
  &lt;/exemple&gt;
&lt;/test&gt;
							</code></pre>
							<div class="fragment">
								<p>Réponse : oui</p>
								<p>La balise spéciale CDATA permet de délimiter une zone traitée comme du texte.</p>
							</div>
						</article>
					</section>
					<section>
						<article>
							<p>Ce document XML est-il bien formé ?</p>
							<pre><code class="xml">
&lt;test&gt;
  &lt;question&gt;Cette expression est-elle vraie ?&lt;/question&gt;
  &lt;expression&gt;2 &lt; 3&lt;/expression&gt;
&lt;/test&gt;
							</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Réponse : non</p>
							<p>Les caractères &amp; ' &quot; &lt; &gt; doivent être échappés respectivement par &amp;amp; &amp;apos; &amp;quot; &amp;lt; &amp;gt;</p>
							<pre><code class="xml">
&lt;test&gt;
  &lt;question&gt;Cette expression est-elle vraie ?&lt;/question&gt;
  &lt;expression&gt;2 &amp;lt; 3&lt;/expression&gt;
&lt;/test&gt;
							</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Un élément d'un document XML peut être associé à un espace de nom.
							Un espace de nom XML (<strong>XML namespace</strong>) est identifié par une URI. Un espace de nom
							est déclaré grâce à l'attribut <strong>xmlns</strong>.
							</p>
						</article>
					</section>
					<section>
						<article>
							<figure>
								<figcaption>Déclaration d'un espace de nom XML</figcaption>
								<pre><code class="xml">&lt;programme xmlns="http://epsi.fr/syllabus"&gt;
  &lt;cours code="I4GL"&gt;
    &lt;intitulé&gt;Génie logiciel&lt;/intitulé&gt;
  &lt;/cours&gt;
  &lt;cours code="I4WS"&gt;
    &lt;intitulé&gt;Web services&lt;/intitulé&gt;
  &lt;/cours&gt;
&lt;/programme&gt;</code></pre>
							</figure>
							<p>Un espace de nom XML s'applique à l'élément portant l'attribut 
							xmlns <strong>et</strong> à tous les éléments fils.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Il est possible de mélanger dans un même document XML des éléments appartenant
							à des espaces de noms différents.</p>
							<figure>
								<figcaption>Document XML contenant plusieurs espaces de nom</figcaption>
								<pre><code class="xml">&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;body&gt;
    &lt;h1&gt;Exemple MathML&lt;/h1&gt;
    &lt;math xmlns="http://www.w3.org/1998/Math/MathML"&gt;
      &lt;mrow&gt;
        &lt;mroot&gt;
          &lt;mrow&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;
          &lt;mrow&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;
        &lt;/mroot&gt;
      &lt;/mrow&gt;
    &lt;/math&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Afin de résoudre les cas ambigus, un espace de nom peut être identifié par un préfixe.</p>
							<figure>
								<figcaption>Document XML contenant plusieurs espaces de nom avec un préfixe</figcaption>
								<pre><code class="xml">&lt;h:html xmlns:h="http://www.w3.org/1999/xhtml"
        xmlns:ma="http://www.w3.org/1998/Math/MathML"&gt;
  &lt;h:body&gt;
    &lt;h:h1&gt;Exemple MathML&lt;/h:h1&gt;
    &lt;ma:math&gt;
      &lt;ma:mrow&gt;
        &lt;ma:mroot&gt;
          &lt;ma:mrow&gt;&lt;ma:mi&gt;b&lt;/ma:mi&gt;&lt;/ma:mrow&gt;
          &lt;ma:mrow&gt;&lt;ma:mn&gt;3&lt;/ma:mn&gt;&lt;/ma:mrow&gt;
        &lt;/ma:mroot&gt;
      &lt;/ma:mrow&gt;
    &lt;/ma:math&gt;
  &lt;/h:body&gt;
&lt;/h:html&gt;</code></pre>
							</figure>
							<p>L'espace de nom sans préfixe est appelé l'espace de nom par défaut (<strong>default XML namespace</strong>).</p>
						</article>
					</section>
					<section>
						<article>
							<p>Un élément XML est défini par :</p>
							<dl>
								<dt>Son nom</dt>
								<dd>Le nom apparaît dans la balise du document.<br>Exemple : body</dd>
								<dt>Son espace de nom</dt>
								<dd>L'espace de nom est donné par l'attribut xmlns de l'élément, un préfixe ou est hérité de l'élément parent.<br>Exemple : http://www.w3.org/1999/xhtml</dd>
								<dt>Son nom qualifié (qualified name ou QName)</dt>
								<dd>L'association de l'espace de nom et du nom de l'élement. Il s'agit en fait du nom complet de l'élement.<br>
								Exemple : {http://www.w3.org/1999/xhtml}:body</dd>
							</dl>
						</article>
					</section>
					<section>
						<article>
							<p>Un document XML est <strong>valide</strong> (valid) si le QName et l'ordre des éléments
							sont conformes à un document de validation.</p>
						</article>
					</section>
					<section>
						<article>
							<p>Un <strong>schéma XML</strong> (XSD) permet d'écrire un document de validation au format XML.</p>
							<figure>
								<figcaption>Exemple de schéma XML</figcaption>
								<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:tns="http://epsi.fr/syllabus" 
        targetNamespace="http://epsi.fr/syllabus"
        elementFormDefault="qualified"&gt;
  &lt;element name="programme"&gt;
    &lt;complexType&gt;
      &lt;sequence&gt;
        &lt;element name="cours" type="tns:typeCours" 
         maxOccurs="unbounded" minOccurs="0"/&gt;
      &lt;/sequence&gt;
    &lt;/complexType&gt;
  &lt;/element&gt;
  &lt;complexType name="typeCours"&gt;
    &lt;sequence&gt;
      &lt;element name="intitulé" type="string" 
       maxOccurs="1" minOccurs="1"/&gt;
    &lt;/sequence&gt;
    &lt;attribute name="code" type="string"/&gt;
  &lt;/complexType&gt;
&lt;/schema&gt;</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<header>Pour aller plus loin...</header>
							<dl>
								<dt>XML</dt>
								<dd><a href="http://www.w3schools.com/xml/" class="explicit" target="_blank">http://www.w3schools.com/xml/</a></dd>
								<dt>XML namespace</dt>
								<dd><a href="http://www.w3schools.com/xml/xml_namespaces.asp" class="explicit" target="_blank">http://www.w3schools.com/xml/xml_namespaces.asp</a></dd>
								<dt>XML schema</dt>
								<dd><a href="http://www.w3schools.com/schema/" class="explicit" target="_blank">http://www.w3schools.com/schema/</a></dd>
							</dl>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>SOAP : le langage d'échange</header>
							<!-- Présenter le format SOAP ainsi que le protocole de gestion des erreurs (SOAP Fault) et les envoi asynchrone  -->
							<p>SOAP est un simple format de message définit par un schéma XML.</p>
							<p>Ce schéma XML est disponible à l'adresse de son namespace XML :<br> 
							<a href="http://schemas.xmlsoap.org/soap/envelope/" class="explicit" target="_blank">http://schemas.xmlsoap.org/soap/envelope/</a></p>
						</article>
					</section>
					<section>
						<article>
							<figure>
								<figcaption>Structure d'un message SOAP</figcaption>
								<pre><code class="xml">&lt;!-- l'enveloppe du message --&gt; 
&lt;soapenv:Envelope 
   xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;

  &lt;!-- l'en-tête du message --&gt;
  &lt;soapenv:Header&gt;
    &lt;!-- les éventuelles méta-informations --&gt;
  &lt;/soapenv:Header&gt;

  &lt;!-- le corps de la requête --&gt;
  &lt;soapenv:Body&gt;
    &lt;!-- le message (payload) --&gt;
  &lt;/soapenv:Body&gt;

&lt;/soapenv:Envelope&gt;</code></pre>
							</figure>
							<p>Le format d'un message est le même pour la requête et pour la réponse.</p>
						</article>
					</section>
					<section>
						<article>
							<p>SOAP définit un format pour un type de réponse particulière : une SOAP fault.</p>
							<p>Une SOAP fault signale un problème lors du traitement de la requête.</p>
							<figure>
								<figcaption>Une réponse contenant une SOAP fault</figcaption>
								<pre><code class="xml">&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
   &lt;soap:Body&gt;
      &lt;soap:Fault&gt;
         &lt;faultcode&gt;soap:Server&lt;/faultcode&gt;
         &lt;faultstring&gt;Internal server error&lt;/faultstring&gt;
      &lt;/soap:Fault&gt;
   &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Avec JAX-WS, la SEI peut récupérer les informations provenant du corps de la requête
							mais aussi des en-têtes.</p>
							<p>L'annotation <a href="http://docs.oracle.com/javaee/6/api/javax/jws/WebParam.html" target="_blank">@WebParam</a> possède les attributs suivants :</p>
							<dl>
								<dt>name</dt>
								<dd>le nom de l'élement XML</dd>
								<dt>targetNamespace</dt>
								<dd>l'espace de nom de l'élement XML</dd>
								<dt>header</dt>
								<dd>un booléan indiquant si l'élement XML doit être extrait de l'en-tête ou s'il s'agit du corps
								du message.</dd>
							</dl>
							
						</article>
					</section>
					<section>
						<article>
							<p>Avec JAX-WS, la SEI peut déclarer des méthodes ayant plusieurs valeurs de retour : le corps de la réponse mais aussi les en-têtes de la réponse.</p>
							<p>L'annotation <a href="http://docs.oracle.com/javaee/6/api/javax/jws/WebParam.html" target="_blank" class="explicit">@WebParam</a> possède l'attribut suivant :</p>
							<dl>
								<dt>mode</dt>
								<dd>Il s'agit d'une énumération pouvant prendre les valeurs IN, OUT ou INOUT.
								Pour les valeurs OUT et INOUT, le type du paramètre est obligatoirement de type
								<a href="http://docs.oracle.com/javaee/6/api/javax/xml/ws/Holder.html" target="_blank">javax.xml.ws.Holder&lt;T&gt;</a>.
								</dd>
							</dl>
							<pre><code class="java">
public Comments sayHello(@WebParam Article article, 
     @WebParam(header=true) editorCredentials,
     @WebParam(header=true, mode=Mode.OUT) Holder&lt;ServerInfo&gt; serverInfo) {
}
                         	</code></pre>
						</article>
					</section>
					<section>
						<article>
							<p>Avec JAX-WS, les exceptions lancées par une méthode d'une SEI sont automatiquement
							transformées en SOAP fault.</p>
						</article>
					</section>
					<!-- Parler du oneway -->
					<section>
						<article>
							<p>JAX-WS définit une annotation particulière : <a href="http://docs.oracle.com/javaee/6/api/javax/jws/Oneway.html" target="_blank">@Oneway</a>.
							Cette annotation ne peut être utilisée que sur des méthodes n'ayant aucune valeur de retour 
							(la méthode retourne void, elle ne déclare aucun paramètre OUT ou INOUT et elle ne lance aucune exception).
							</p>
							<p>Une méthode @Oneway permet de réaliser un traitement asynchrone : une réponse SOAP est retournée
							au client pendant que la méthode est exécutée.</p>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>WSDL</header>
							<p>La condition pour utiliser un service Web SOAP est de connaître les opérations
							disponibles et le format des requêtes et des réponses.</p>
							<p><strong>WSDL (Web Service Description Language)</strong> est un langage XML permettant la
							description complète d'un service Web SOAP.</p>
						</article>
					</section>
					<section>
						<article>
							<p>La plupart des <em>stacks</em> SOAP donne accès au WSDL
							(en le générant dynamiquement si nécessaire).</p>
							<p>Pour les serveurs d'application Java EE, le WSDL est disponible à la même URL que le service 
							en ajoutant <strong>wsdl</strong> comme paramètre.</p>
							<p>Exemple : <a href="http://localhost:8080/hello-service/webservices/HelloService?wsdl" class="explicit" target="_blank">http://localhost:8080/hello-service/webservices/HelloService?wsdl</a></p>
						</article>
					</section>
					<section>
						<article>
							<figure>
								<figcaption>Structure d'un WSDL</figcaption>
								<pre><code class="xml">&lt;wsdl:definitions 
  xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" 
  xmlns:tns="http://epsi/" 
  xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
  xmlns:ns1="http://schemas.xmlsoap.org/soap/http" 
  name="HelloServiceService" targetNamespace="http://epsi/"&gt;</code></pre>

  								<figcaption>Les types de données au format XML schema</figcaption>
								<pre><code class="xml">  &lt;wsdl:types&gt;
    &lt;!-- on trouve ici le schéma XML décrivrant le contenu des messages --&gt;
  &lt;/wsdl:types&gt;</code></pre>

  								<figcaption>Description des messages</figcaption>
								<pre><code class="xml">  &lt;wsdl:message name="sayHelloResponse"&gt;
    &lt;wsdl:part element="tns:sayHelloResponse" name="result"/&gt;
    &lt;wsdl:part element="tns:serverTime" name="serverTime"/&gt;
  &lt;/wsdl:message&gt;
  &lt;wsdl:message name="sayHello"&gt;
    &lt;wsdl:part element="tns:sayHello" name="parameters"/&gt;
  &lt;/wsdl:message&gt;</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<figure>
  								<figcaption>Description des interfaces (indépendant de SOAP)</figcaption>
								<pre><code class="xml">  &lt;wsdl:portType name="HelloService"&gt;
    &lt;wsdl:operation name="sayHello"&gt;
      &lt;wsdl:input message="tns:sayHello" name="sayHello"/&gt;
      &lt;wsdl:output message="tns:sayHelloResponse" name="sayHelloResponse"/&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:portType&gt;</code></pre>

  								<figcaption>Liaison des interfaces avec le protocole SOAP</figcaption>
								<pre><code class="xml">  &lt;wsdl:binding name="HelloServiceServiceSoapBinding" 
                type="tns:HelloService"&gt;
    &lt;soap:binding style="document" 
                  transport="http://schemas.xmlsoap.org/soap/http"/&gt;
    &lt;wsdl:operation name="sayHello"&gt;
      &lt;soap:operation soapAction="" style="document"/&gt;
      &lt;wsdl:input name="sayHello"&gt;
        &lt;soap:body use="literal"/&gt;
      &lt;/wsdl:input&gt;
      &lt;wsdl:output name="sayHelloResponse"&gt;
	&lt;soap:header message="tns:sayHelloResponse" 
	             part="serverTime" use="literal"/&gt;
        &lt;soap:body parts="result" use="literal"/&gt;
      &lt;/wsdl:output&gt;
    &lt;/wsdl:operation&gt;
  &lt;/wsdl:binding&gt;</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<figure>
  								<figcaption>Localisation du service</figcaption>
								<pre><code class="xml">  &lt;wsdl:service name="HelloServiceService"&gt;
    &lt;wsdl:port binding="tns:HelloServiceServiceSoapBinding" 
               name="HelloServicePort"&gt;
      &lt;soap:address location="http://localhost:8080/hello-service/webservices/HelloService"/&gt;
    &lt;/wsdl:port&gt;
  &lt;/wsdl:service&gt;</code></pre>

								<pre><code class="xml">&lt;/wsdl:definitions&gt;</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<header>Pour aller plus loin...</header>
							<dl>
								<dt>WSDL</dt>
								<dd><a href="http://www.w3schools.com/webservices/ws_wsdl_intro.asp" class="explicit" target="_blank">http://www.w3schools.com/webservices/ws_wsdl_intro.asp</a></dd>
 							</dl>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>Développer un service Web SOAP</header>
							<p>On distingue deux approches pour développer un service Web WS-* :</p>
							<dl>
								<dt>Contract first</dt>
								<dd>On définit le contrat du service en spécifiant le WSDL et on utilise des outils pour générer le code.</dd>
								<dt>Contract last</dt>
								<dd>On développe le service et on utilise des outils pour générer le WSDL.</dd>
							</dl>
						</article>
					</section>
					<section>
						<article>
							<p>Les outils Java</p>
							<dl>
								<dt>Java &#8594; WSDL (Contract last)</dt>
								<dd>On peut demander au serveur de générer le WSDL après le déploiement du service en passant <em>wsdl</em> comme paramètre de l'URL.<br>
								L'utilitaire <strong><a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/wsgen.html" target="_blank">wsgen</a></strong> 
								livré avec le JDK peut générer un fichier WSDL à partir d'une classe compilée.</dd>
								<dt>WSDL &#8594; Java (Contract first)</dt>
								<dd>L'utilitaire <strong><a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/wsimport.html" target="_blank">wsimport</a></strong> livré avec le JDK.</dd>
							</dl>
						</article>
					</section>
					<section>
						<article>
							<p>Pour utiliser <strong><a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/wsimport.html" target="_blank" class="explicit">wsimport</a></strong> :</p>
							<figure>
								<figcaption>Générer les classes compilées</figcaption>
								<pre><code class="bash">wsimport http://localhost:8080/hello-service/webservices/HelloService?wsdl</code></pre>
								<figcaption>Générer uniquement les sources</figcaption>
								<pre><code class="bash">wsimport -Xnocompile http://localhost:8080/hello-service/webservices/HelloService?wsdl</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Une fois la SEI (Service Endpoint Interface) générée par wsimport, 
							il suffit de fournir une implémentation de cette interface.</p>
							<figure>
								<figcaption>Exemple de l'implémentation d'une SEI</figcaption>
								<pre><code class="java">
// Nécessaire uniquement avec TomEE. 
// L'attribut name spécifie la terminaison de l'URL d'accès au service.
@Stateless(name="HelloService")
// L'attribut endpointInterface désigne l'interface annotée avec JAX-WS.
@WebService(endpointInterface="epsi.HelloService")
public class HelloServiceImpl implements epsi.HelloService {

  @Override
  public SayHelloResponse sayHello(SayHello parameters) {
    // ...
  }

}
								</code></pre>
							</figure>
						</article>
					</section>
				</section>
				<section>
					<section>
						<article>
							<header>Consommer des services Web SOAP avec JAX-WS</header>
							<p>Une application cliente d'un service Web SOAP utilise un <strong>stub</strong>.
							Un stub est une classe générée qui masque la complexité des échanges de messages
							avec le serveur.
							</p>
						</article>
					</section>
					<section>
						<article>
							<p>Il est possible de créer un client à partir du code généré par <strong>wsimport</strong>.</p>
							<figure>
								<figcaption>Exemple d'accès à la SEI pour un client</figcaption>
								<pre><code class="java">
// L'URL du WSDL (peut-être un fichier sur disque)
URL wsdlDocumentLocation = new URL("file:HelloService.wsdl");

// Le qualified name du service spécifié par les attributs 
// targetNamespace et name de la balise racine dans le WSDL
QName serviceName = new QName("http://epsi/","HelloServiceService");

// HelloServiceService est une classe générée par wsimport
Service service = HelloServiceService.create(wsdlDocumentLocation, 
                                             serviceName);

// La SEI offrant les méthodes du service Web
HelloService helloService = service.getPort(HelloService.class);
								</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Le code précédent pose un problème : le client utilise l'URL du service 
							spécifié dans la section <em>wsdl:service</em> du WSDL. Il est souvent
							utile de pouvoir changer dynamiquement l'URL du endpoint.</p>
							<figure>
								<figcaption>Modification de l'URL du endpoint du service</figcaption>
								<pre><code class="java">
URL wsdlDocumentLocation = new URL("file:HelloService.wsdl");
QName serviceName = new QName("http://epsi/","HelloServiceService");

Service service = HelloServiceService.create(wsdlDocumentLocation, 
                                             serviceName);

HelloService helloService = service.getPort(HelloService.class);

// Un service implémente l'interface javax.xml.ws.BindingProvider
BindingProvider bp = (BindingProvider) helloService;
// endpointUrl est un variable donnant l'URL du endpoint
bp.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, 
                           endpointUrl);
								</code></pre>
							</figure>
						</article>
					</section>
					<section>
						<article>
							<p>Pour une application Java EE, le stub client est une ressource
							que l'on peut injecter avec l'annotation 
							<strong><a href="http://docs.oracle.com/javaee/6/api/javax/xml/ws/WebServiceRef.html" target="_blank">@WebServiceRef</a></strong>.</p>
							<pre><code class="java">
import javax.ejb.Stateless;
import javax.xml.ws.WebServiceRef;

import epsi.HelloServiceService

@Stateless
public class MyWebServiceClient {

  @WebServiceRef
  HelloServiceService helloService;
  
  // ...
}
							</code></pre>
							<p>Attention, le stub client n'est pas <strong>thread-safe</strong> !</p>
						</article>
					</section>
				</section>
				<section>
					<section>
						<h2>WS-* ou RESTful ?</h2>
					</section>
				</section>
			</div>

		</div>

		<script src="assets/reveal.js-2.5.0/lib/js/head.min.js"></script>
		<script src="assets/reveal.js-2.5.0/js/reveal.min.js"></script>

		<script>
		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,
			transition: "linear",

			// Optional libraries used to extend on reveal.js
			dependencies: [
				{ src: 'assets/reveal.js-2.5.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
				{ src: 'assets/reveal.js-2.5.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
				{ src: 'assets/reveal.js-2.5.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
				{ src: 'assets/reveal.js-2.5.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
			]
		});
		</script>

	</body>
</html>
